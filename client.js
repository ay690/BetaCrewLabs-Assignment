// I-am-autogenerated
const net = require("net");
const fs = require("fs");

// Server connection settings
const HOST = '127.0.0.1';
const PORT = 3000;

// Packet format constants
const PACKET_SIZE = 4 + 1 + 4 + 4 + 4; // symbol(4) + indicator(1) + quantity(4) + price(4) + seq(4)
const PACKET_JSON_FILE = "orderBook.json";

let receivedPackets = {};
let done = false;

// Helper to parse a single packet buffer
function parsePacket(buffer) {
  let offset = 0;
  const symbol = buffer.slice(offset, offset + 4).toString("ascii").trim();
  offset += 4;
  const buySellIndicator = buffer.slice(offset, offset + 1).toString("ascii");
  offset += 1;
  const quantity = buffer.readInt32BE(offset);
  offset += 4;
  const price = buffer.readInt32BE(offset);
  offset += 4;
  const packetSequence = buffer.readInt32BE(offset);
  return { symbol, buySellIndicator, quantity, price, packetSequence };
}

// Request to stream all packets (callType=1)
function streamAll() {
  return new Promise((resolve, reject) => {
    const client = net.createConnection({ host: HOST, port: PORT }, () => {
      const req = Buffer.alloc(2);
      req.writeUInt8(1, 0); // callType 1
      req.writeUInt8(0, 1); // padding
      client.write(req);
    });

    let bufferCollector = Buffer.alloc(0);
    const packets = [];

    client.on("data", data => {
      bufferCollector = Buffer.concat([bufferCollector, data]);
      while (bufferCollector.length >= PACKET_SIZE) {
        const chunk = bufferCollector.slice(0, PACKET_SIZE);
        bufferCollector = bufferCollector.slice(PACKET_SIZE);
        packets.push(parsePacket(chunk));
      }
    });

    client.on("end", () => resolve(packets));
    client.on("error", err => reject(err));
  });
}

// Request a specific packet by sequence (callType=2)
function requestSeq(seq) {
  return new Promise((resolve, reject) => {
    const client = net.createConnection({ host: HOST, port: PORT }, () => {
      const req = Buffer.alloc(2);
      req.writeUInt8(2, 0); // callType 2
      req.writeUInt8(seq, 1); // resendSeq
      client.write(req);
    });

    let bufferCollector = Buffer.alloc(0);
    client.on("data", data => {
      bufferCollector = Buffer.concat([bufferCollector, data]);
      if (bufferCollector.length >= PACKET_SIZE) {
        const packet = parsePacket(bufferCollector.slice(0, PACKET_SIZE));
        resolve(packet);
        client.end();
      }
    });
    client.on("error", err => reject(err));
  });
}

// Save packets array to JSON file
function savePacketsToFile(packets) {
  fs.writeFileSync(PACKET_JSON_FILE, JSON.stringify(packets, null, 2));
  console.log(`${PACKET_JSON_FILE} created with ${packets.length} packets.`);
}

// Main workflow
(async () => {
  try {
    // 1. Stream all packets
    const initial = await streamAll();
    console.log(`Received ${initial.length} packets from stream.`);

    // 2. Identify missing sequences dynamically
    const seqs = initial.map(p => p.packetSequence);
    const maxSeq = Math.max(...seqs);
    const missing = [];
    for (let i = 1; i <= maxSeq; i++) {
      if (!seqs.includes(i)) missing.push(i);
    }
    console.log(`Missing sequences: ${missing.length ? missing.join(', ') : 'None'}`);

    // 3. Recover missing packets
    const recovered = [];
    for (const seq of missing) {
      /* eslint-disable no-await-in-loop */
      const pkt = await requestSeq(seq);
      recovered.push(pkt);
    }

    // 4. Combine and sort all packets
    const allPackets = [...initial, ...recovered]
      .sort((a, b) => a.packetSequence - b.packetSequence);

    // 5. Save to JSON
    savePacketsToFile(allPackets);
  } catch (err) {
    console.error('Error:', err);
  }
})();

// The structure and functions are designed to handle client-server communication according to the provided specifications.